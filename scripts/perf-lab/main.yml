name: spring-quarkus-perf-comparison
states:
  env.run.host.user: someuser
  env.run.host.name: 127.0.0.1
  env.run.host.target: ${{env.run.host.user}}@${{env.run.host.name}}

  config.jvm.version: 25.0.1-tem
  config.jvm.graalvm.version: 25.0.1-graalce

  config.quarkus.version: #3.28.3
  config.springboot3.version: #3.5.6
  config.springboot4.version: #4.0.0

  config.jvm.memory: #-Xmx128m
  config.jvm.args: #-XX:+UseNUMA
  config.quarkus.build_config_args: 

  config.quarkus.native_build_options: #-Dquarkus.native.native-image-xmx=<maximum_memory>
  config.springboot3.native_build_options:
  config.springboot4.native_build_options:

  config.resources.cpu.app: 0-3
  config.resources.cpu.db: 4-6
  config.resources.cpu.load_generator: 7-9
  config.resources.cpu.1st_request: 10
  config.resources.cpu.monitor: 11

  config.profiler.name: none #jfr flamegraph
  config.profiler.events: cpu

  config.repo.branch: main
  config.repo.url: https://github.com/quarkusio/spring-quarkus-perf-comparison.git

  config.num_iterations: 3

  APP_CMD_PREFIX: taskset --cpu-list ${{config.resources.cpu.app}}
  LOAD_GEN_CMD_PREFIX: taskset --cpu-list ${{config.resources.cpu.load_generator}}
  MONITOR_CMD_PREFIX: taskset --cpu-list ${{config.resources.cpu.monitor}}
  RUN.WRK_BIN: ${{LOAD_GEN_CMD_PREFIX}} jbang -R -XX:+UseNUMA wrk@hyperfoil

  DROP_OS_FILESYSTEM_CACHES:
  PAUSE_TIME: 5
  PROFILER_JVM_ARGS:
  BASE_JAVA_CMD: ${{APP_CMD_PREFIX}} java ${{config.jvm.memory}} ${{config.jvm.args}} ${{PROFILER_JVM_ARGS}}
  TESTS : [test-build, measure-build-times, measure-time-to-first-request, measure-rss, run-load-test]
  RUNTIMES: [quarkus3-jvm, quarkus3-native, spring3-jvm, spring3-jvm-aot, spring3-native, spring4-jvm, spring4-jvm-aot, spring4-native]
  TARGET_URL: http://localhost:8080/fruits
  QUARKUS-PLATFORM-ARTIFACT-ID: quarkus-bom
  PROJ_REPO_NAME: spring-quarkus-perf-comparison
  METRICS_DIR: /tmp
  ASYNC_PROFILER: async-profiler
  RUNTIMECMDS:
    - name: quarkus3-jvm
      type: jvm
      dir: ${{QUARKUS3_DIR}}
      updateScript: update-quarkus-version
      updateVersion: ${{config.quarkus.version}}
      buildCmd: "./mvnw ${{config.quarkus.build_config_args}} clean package -DskipTests"
      runCmd: "${{BASE_JAVA_CMD}} -jar ${{QUARKUS3_DIR}}/target/quarkus-app/quarkus-run.jar"
      logFileStartedRegex: ".*quarkus3.+started in.*"
    - name: quarkus3-native
      type: native
      dir: ${{QUARKUS3_DIR}}
      updateScript: update-quarkus-version
      updateVersion: ${{config.quarkus.version}}
      buildCmd: "./mvnw ${{config.quarkus.build_config_args}} clean package -DskipTests -Pnative ${{config.quarkus.native_build_options}}"
      runCmd: "${{APP_CMD_PREFIX}} ${{QUARKUS3_DIR}}/target/quarkus3-runner ${{config.jvm.memory}}"
      logFileStartedRegex: ".*quarkus3.+started in.*"
    - name: spring3-jvm
      type: jvm
      dir: ${{SPRING3_BOOT_DIR}}
      updateScript: update-spring-boot-version
      updateVersion: ${{config.springboot3.version}}
      buildCmd: "./mvnw clean package -DskipTests"
      runCmd: "${{BASE_JAVA_CMD}} -jar ${{SPRING3_BOOT_DIR}}/target/springboot3.jar"
      logFileStartedRegex: ".*Started SpringBoot3Application in.+seconds.*"
    - name: spring3-jvm-aot
      type: jvm
      dir: ${{SPRING3_BOOT_DIR}}
      updateScript: update-spring-boot-version
      updateVersion: ${{config.springboot3.version}}
      buildCmd: "./mvnw clean compile spring-boot:process-aot package -DskipTests"
      runCmd: "${{BASE_JAVA_CMD}} -Dspring.aot.enabled=true -jar ${{SPRING3_BOOT_DIR}}/target/springboot3.jar"
      logFileStartedRegex: ".*Started SpringBoot3Application in.+seconds.*"
    - name: spring3-native
      type: native
      dir: ${{SPRING3_BOOT_DIR}}
      updateScript: update-spring-boot-version
      updateVersion: ${{config.springboot3.version}}
      buildCmd: "./mvnw clean -Pnative -DskipTests native:compile package ${{config.springboot3.native_build_options}}"
      runCmd: "${{APP_CMD_PREFIX}} ${{SPRING3_BOOT_DIR}}/target/springboot3 ${{config.jvm.memory}}"
      logFileStartedRegex: ".*Started SpringBoot3Application in.+seconds.*"
    - name: spring4-jvm
      type: jvm
      dir: ${{SPRING4_BOOT_DIR}}
      updateScript: update-spring-boot-version
      updateVersion: ${{config.springboot4.version}}
      buildCmd: "./mvnw clean package -DskipTests"
      runCmd: "${{BASE_JAVA_CMD}} -jar ${{SPRING4_BOOT_DIR}}/target/springboot4.jar"
      logFileStartedRegex: ".*Started SpringBoot4Application in.+seconds.*"
    - name: spring4-jvm-aot
      type: jvm
      dir: ${{SPRING4_BOOT_DIR}}
      updateScript: update-spring-boot-version
      updateVersion: ${{config.springboot4.version}}
      buildCmd: "./mvnw clean compile spring-boot:process-aot package -DskipTests"
      runCmd: "${{BASE_JAVA_CMD}} -Dspring.aot.enabled=true -jar ${{SPRING4_BOOT_DIR}}/target/springboot4.jar"
      logFileStartedRegex: ".*Started SpringBoot4Application in.+seconds.*"
    - name: spring4-native
      type: native
      dir: ${{SPRING4_BOOT_DIR}}
      updateScript: update-spring-boot-version
      updateVersion: ${{config.springboot4.version}}
      buildCmd: "./mvnw clean -Pnative -DskipTests native:compile package ${{config.springboot4.native_build_options}}"
      runCmd: "${{APP_CMD_PREFIX}} ${{SPRING4_BOOT_DIR}}/target/springboot4 ${{config.jvm.memory}}"
      logFileStartedRegex: ".*Started SpringBoot4Application in.+seconds.*"

scripts:
  update-state:
    - sh: echo $(realpath ~)
    - set-state: RUN.BASE_DIR
    - set-state: RUN.REPO_DIR ${{BASE_DIR}}/spring-quarkus-perf-comparison
    - set-state: RUN.HYPERFOIL_LOGS_DIR ${{REPO_DIR}}/logs/hyperfoil
    - set-state: RUN.PROJ_REPO_DIR ${{REPO_DIR}}/${{PROJ_REPO_NAME}}
    - set-state: RUN.SCRIPTS_DIR ${{PROJ_REPO_DIR}}/scripts/perf-lab
    - set-state: RUN.HELPER_SCRIPTS_DIR ${{SCRIPTS_DIR}}/scripts
    - set-state: RUN.SPRING3_BOOT_DIR ${{REPO_DIR}}/${{PROJ_REPO_NAME}}/springboot3
    - set-state: RUN.SPRING4_BOOT_DIR ${{REPO_DIR}}/${{PROJ_REPO_NAME}}/springboot4
    - set-state: RUN.QUARKUS3_DIR ${{REPO_DIR}}/${{PROJ_REPO_NAME}}/quarkus3
    - set-state: RUN.ASYNC_PROFILER_DIR ${{BASE_DIR}}/${{ASYNC_PROFILER}}

  output-vars:
    - log: |
        "Config: ${{config}}"
        "ENV: ${{env}}"
        "BASE_DIR: ${{BASE_DIR}}"
        "REPO_DIR: ${{REPO_DIR}}"
        "HYPERFOIL_LOGS_DIR: ${{HYPERFOIL_LOGS_DIR}}"
        "SCRIPTS_DIR: ${{SCRIPTS_DIR}}"
        "SPRING3_BOOT_DIR: ${{SPRING3_BOOT_DIR}}"
        "SPRING4_BOOT_DIR: ${{SPRING4_BOOT_DIR}}"
        "QUARKUS3_DIR : ${{QUARKUS3_DIR}}"
        "RUNTIMECMDS: ${{RUNTIMECMDS}}"

  capture-repo-info:
    - sh: cd ${{PROJ_REPO_DIR}}
    - sh: git rev-parse HEAD
    - set-state: RUN.config.repo.commit

  cleanup-env:
    - script: sudo
      with:
        command: rm -Rf ${{PROJ_REPO_DIR}}

  config-env:
    - script: sudo
      with:
        command: rm -Rf ${{REPO_DIR}}/logs
    - sh: mkdir -p ${{REPO_DIR}}/logs
    - sh: mkdir -p ${{HYPERFOIL_LOGS_DIR}}

  clone-repo:
    - script: sudo
      with:
        command: rm -Rf ${{REPO_DIR}}
    - sh: mkdir -p ${{REPO_DIR}}/logs
    - sh: cd ${{REPO_DIR}}
    - log: Cloning project repo ${{config.repo.branch}}@${{config.repo.url}}
    - sh: git clone -b ${{config.repo.branch}} ${{config.repo.url}}
    - sh: cd ${{PROJ_REPO_NAME}}
    - log: Checked out repo
    - sh: git remote get-url origin
    - sh: git branch --show-current

  update-spring-boot-version:
    - script: check-dependency-exists
      with:
        groupId: org.springframework.boot
        artifactId: spring-boot-starter-parent
        version: ${{VERSION}}
    - sh: ./mvnw versions:update-parent "-DparentVersion=[${{VERSION}}]" -DskipResolution=true

  update-quarkus-version:
    - script: check-dependency-exists
      with:
        groupId: io.quarkus.platform
        artifactId: quarkus-bom
        version: ${{VERSION}}
    - sh: ./mvnw versions:set-property -Dproperty=quarkus.platform.version -DnewVersion=${{VERSION}}

  start-test-services:
    - sh: ${{PROJ_REPO_DIR}}/scripts/infra.sh -c 3 -p '${{config.resources.cpu.db}}' -s
      watch:
        - regex: "Error: PostgreSQL failed to become ready"
          then:
            - abort: PostgreSQL failed to become ready

  stop-test-services:
    - sh: ${{PROJ_REPO_DIR}}/scripts/infra.sh -d

  run-tests:
    - sh: java -version
    - sh: echo $$
    - set-state: RUN.SHELL_PID
    - for-each: RUNTIME ${{RUNTIMES}}
      then:
        - set-state: RUNTIMECMD ${{RUNTIMECMDS[?(@.name == '${{RUNTIME}}')]}}
        - log: "Updating version: ${{RUNTIMECMD.updateVersion:}}"
        - script: ${{RUNTIMECMD.updateScript:abort-script-not-found}}
          with:
            DIR: ${{RUNTIMECMD.dir}}
            VERSION: ${{RUNTIMECMD.updateVersion:}}
        - log: "Testing: ${{RUNTIME}}"
        - for-each: TEST ${{TESTS}}
          then:
          - script: ${{TEST}}
            with:
              RUNTIME: ${{RUNTIMECMD}}

  abort-script-not-found:
    - abort: script not found

  test-build:
    - log: Test Build - ${{RUNTIME.name}}
    - sh: cd ${{RUNTIME.dir}}
    - sh: java -version
    - sh: ${{RUNTIME.buildCmd}}
      watch:
      - regex: BUILD FAILURE
        then:
          - abort: failed to build ${{RUNTIME.name}}

  measure-build-times:
    - log: Build times
    - sh: cd ${{RUNTIME.dir}}
    - log: JVM version
    - sh: java -version
    - log: Graal VM Version
    - sh: $GRAALVM_HOME/bin/java -version
    - set-state: TYPE ${{RUNTIME.type}}
    - for-each: ITERATION ${{=[...Array(${{config.num_iterations}}).keys()]}}
      then:
        - queue-download: ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-${{ITERATION}}.log
        - script: sync-drop-fs-cache
        - sh: /usr/bin/time -p ${{RUNTIME.buildCmd}} 2>&1 >${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-${{ITERATION}}.log | grep real | awk '{print $2}'
        - set-state: BUILD_TIME
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.build.timings
            value: ${{BUILD_TIME}}

        # If its a native build, gather the native build rss as well
        - read-state: ${{TYPE}}
          then:
            - regex: native
              then:
                - sh: "sed -n 's/.*Peak RSS: \\([0-9.]*\\)GB.*/\\1/p' ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-${{ITERATION}}.log"
                - set-state: NATIVE_BUILD_RSS
                - script: state-array-push
                  with:
                    array: RUN.output.results.${{RUNTIME.name}}.build.native.rss
                    value: ${{NATIVE_BUILD_RSS}}
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.build.avBuildTime
        array: RUN.output.results.${{RUNTIME.name}}.build.timings

    - read-state: ${{TYPE}}
      then:
        - regex: native
          then:
            # Capture average native build RSS
            - script: state-array-calc-avg
              with:
                var-name: RUN.output.results.${{RUNTIME.name}}.build.avNativeRSS
                array: RUN.output.results.${{RUNTIME.name}}.build.native.rss

            # The following metrics should be the same in all test iterations, so just pick the 1st
            # Capture the binary size
            - sh: "sed -n 's/^[[:space:]]*\\([0-9.]*\\)MB in total image size.*/\\1/p' ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.native.binarySize

            # Capture the number of classes
            - sh: "cat ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log | grep \"types.*fields.*methods found reachable\" | awk '{print $1}'"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.classCount

            # Capture the number of fields
            - sh: "cat ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log | grep \"types.*fields.*methods found reachable\" | awk '{print $3}'"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.fieldCount

            # Capture the number of methods
            - sh: "cat ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log | grep \"types.*fields.*methods found reachable\" | awk '{print $6}'"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.methodCount

            # Capture the number of classes registered for reflection
            - sh: "cat ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log | grep \"types.*fields.*methods registered for reflection\" | awk '{print $1}'"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.reflectionClassCount

            # Capture the number of fields registered for reflection
            - sh: "cat ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log | grep \"types.*fields.*methods registered for reflection\" | awk '{print $3}'"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.reflectionFieldCount

            # Capture the number of methods registered for reflection
            - sh: "cat ${{REPO_DIR}}/logs/build-times-${{RUNTIME.name}}-0.log | grep \"types.*fields.*methods registered for reflection\" | awk '{print $6}'"
            - set-state: RUN.output.results.${{RUNTIME.name}}.build.reflectionMethodCount

  measure-time-to-first-request:
    - log: Measuring Time to first request
    - sh: java -version
    - sh: cd ${{RUNTIME.dir}}
    - sh: ${{RUNTIME.buildCmd}}
    - for-each: ITERATION ${{=[...Array(${{config.num_iterations}}).keys()]}}
      then:
        - queue-download: ${{REPO_DIR}}/logs/measure-time-to-first-request-${{RUNTIME.name}}-${{ITERATION}}.log
        - script: start-test-services
        - script: sync-drop-fs-cache
        - sh: ${{RUNTIME.runCmd}} &>${{REPO_DIR}}/logs/measure-time-to-first-request-${{RUNTIME.name}}-${{ITERATION}}.log &
        - sh: APP_PID=$!
        - sh: timeout 60s bash -c "taskset --cpu-list ${{config.resources.cpu.1st_request}} ${{HELPER_SCRIPTS_DIR}}/time-to-1st-request.sh ${{TARGET_URL}}"
          then:
            - regex: Terminated
              then:
                - sh: kill -15 $APP_PID
                - abort: Run ${{RUNTIME.runCmd}} didn't start within allotted timeout
            - regex: .*\D.*
              then:
                - sh: kill -15 $APP_PID
                - abort: Timeout script returned a non-numeric value
              else:
                - set-state: START_TIME
        - sh: kill -15 $APP_PID
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.startup.timings
            value: ${{START_TIME}}
        - sh: sleep ${{PAUSE_TIME}}
        - script: stop-test-services
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.startup.avStartTime
        array: RUN.output.results.${{RUNTIME.name}}.startup.timings

  measure-rss:
    - log: Measuring RSS
    - sh: java -version
    - sh: cd ${{RUNTIME.dir}}
    - sh: ${{RUNTIME.buildCmd}}
    - for-each: ITERATION ${{=[...Array(${{config.num_iterations}}).keys()]}}
      then:
        - queue-download: ${{REPO_DIR}}/logs/measure-rss-${{RUNTIME.name}}-${{ITERATION}}.log
        - script: start-test-services
        - script: sync-drop-fs-cache
        - sh: ${{RUNTIME.runCmd}} &>${{REPO_DIR}}/logs/measure-rss-${{RUNTIME.name}}-${{ITERATION}}.log &
        - sh: APP_PID=$!
        - sh: sleep ${{PAUSE_TIME}}
        - sh: pmap -x $APP_PID | grep total | awk '{print $4}'
          then:
            - set-state: RSS_STARTUP
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.rss.startup
            value: ${{= ${{RSS_STARTUP}}/1024 }}
        - sh: curl -s  ${{TARGET_URL}} > /dev/null
        - sh: pmap -x $APP_PID | grep total | awk '{print $4}'
          then:
            - set-state: FIRST_REQUEST
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.rss.firstRequest
            value: ${{= ${{FIRST_REQUEST}}/1024 }}
        - sh: kill -15 $APP_PID
        - sh: sleep ${{PAUSE_TIME}}
        - script: stop-test-services
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.rss.avStartupRss
        array: RUN.output.results.${{RUNTIME.name}}.rss.startup
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.rss.avFirstRequestRss
        array: RUN.output.results.${{RUNTIME.name}}.rss.firstRequest

  run-load-test:
    - log: Running workload
    - sh: cd ${{RUNTIME.dir}}
    - sh: ${{RUNTIME.buildCmd}}
    - queue-download: ${{HYPERFOIL_LOGS_DIR}}
    - set-state:
        key: APP_LOG_REGEX
        value: ${{RUNTIME.logFileStartedRegex}}
    - for-each: ITERATION ${{=[...Array(${{config.num_iterations}}).keys()]}}
      then:
        - set-state:
            key: LOG_FILE
            value: ${{REPO_DIR}}/logs/load-test-${{RUNTIME.name}}-${{ITERATION}}.log
        - sh: touch ${{LOG_FILE}}
        - sh: mkdir -p ${{HYPERFOIL_LOGS_DIR}}/${{RUNTIME.name}}-${{ITERATION}}
        - queue-download: ${{REPO_DIR}}/logs/hf-${{RUNTIME.name}}-${{ITERATION}}.log
        - queue-download: ${{LOG_FILE}}
        - script: start-test-services
        - script: sync-drop-fs-cache
        - set-signal: LOAD_STEADY_STATE_START 1
        - set-signal: LOG_REGEX_REACHED 1
        - sh: ${{RUNTIME.runCmd}} &>${{LOG_FILE}} &
        - sh: PID=$!
        - sh: echo $PID
        - set-state: JVM_PID
        - script: monitor-processes
          with:
            pid: ${{JVM_PID}}
            log_dir: ${{REPO_DIR}}/logs
            runtime_name: ${{RUNTIME.name}}
            iteration: ${{ITERATION}}
        - log: JVM_PID = ${{JVM_PID}}
        - read-state: ${{config.profiler.name}}
          then:
            - regex: "jfr|flamegraph"
              then:
                - script: async-profiler-install
                - script: async-profiler-configure
                - script:
                    name: async-profiler-run
                    async: true
                  with:
                    wait_start: LOAD_STEADY_STATE_START
                    pid: ${{JVM_PID}}
                    suffix: "${{ITERATION}}.${{= '${{config.profiler.name}}' == 'jfr' ? 'jfr' : 'html' }}"
                    format: ${{config.profiler.name}}
                    events: ${{config.profiler.events}}
                    delay: 10s
        - script:
            name: watch-log
            async: true
          with:
            log_file: ${{LOG_FILE}}
            log_regex: ${{APP_LOG_REGEX}}
        - wait-for: LOG_REGEX_REACHED
        - signal: LOAD_STEADY_STATE_START
        - sh: |
            ${{LOAD_GEN_CMD_PREFIX}} jbang \
              -Dio.hyperfoil.rootdir=${{HYPERFOIL_LOGS_DIR}}/${{RUNTIME.name}}-${{ITERATION}} \
              -R \
              -XX:+UseNUMA \
              run@hyperfoil \
                -d ${{RUNTIME.name}}-${{ITERATION}} \
                -o ${{HYPERFOIL_LOGS_DIR}}/${{RUNTIME.name}}-${{ITERATION}} \
                ${{SCRIPTS_DIR}}/app-load-test.hf.yml 2>&1 >${{REPO_DIR}}/logs/hf-${{RUNTIME.name}}-${{ITERATION}}.log
        - sh: cat ${{REPO_DIR}}/logs/hf-${{RUNTIME.name}}-${{ITERATION}}.log | grep "Started run" | awk '{print $3}'
          then:
            - set-state:
                key: RUN_NUM
                autoConvert: false

        - sh: cat ${{HYPERFOIL_LOGS_DIR}}/${{RUNTIME.name}}-${{ITERATION}}/run/${{RUN_NUM}}/all.json
          then:
            - set-state: HF_OUTPUT
        - read-state: ${{HF_OUTPUT}}
          then:
            - json: $.info.startTime
              then:
                - set-state: START_TIME
              else:
                - abort: Unable to find startTime in ${{HYPERFOIL_LOGS_DIR}}/${{RUNTIME.name}}-${{ITERATION}}/run/${{RUN_NUM}}/all.json
        - read-state: ${{HF_OUTPUT}}
          then:
            - json: $.info.terminateTime
              then:
                - set-state: TERMINATE_TIME
              else:
                - abort: Unable to find terminateTime in ${{HYPERFOIL_LOGS_DIR}}/${{RUNTIME.name}}-${{ITERATION}}/run/${{RUN_NUM}}/all.json
        - read-state: ${{HF_OUTPUT}}
          then:
            - json: $.stats[?(@.phase == 'loadTest')].total.summary
              then:
                - set-state: SUMMARY
              else:
                - abort: Unable to find summary in ${{HYPERFOIL_LOGS_DIR}}/${{RUNTIME.name}}-${{ITERATION}}/run/${{RUN_NUM}}/all.json
        - read-state: ${{SUMMARY}}
          then:
            - json: $.requestCount
              then:
                - set-state: REQUEST_COUNT
              else:
                - abort: Unable to find request count in ${{HYPERFOIL_LOGS_DIR}}/${{RUNTIME.name}}-${{ITERATION}}/run/${{RUN_NUM}}/all.json
        - read-state: ${{SUMMARY}}
          then:
            - json: $.connectionErrors
              then:
                - set-state: CONNECTION_ERRORS
              else:
                - set-state: CONNECTION_ERRORS 0
        - read-state: ${{SUMMARY}}
          then:
            - json: $.requestTimeouts
              then:
                - set-state: REQUEST_TIMEOUTS
              else:
                - set-state: REQUEST_TIMEOUTS 0
        - set-state:
            key: THROUGHPUT
            value: ${{= ${{REQUEST_COUNT}}/((${{TERMINATE_TIME}}-${{START_TIME}})/1000) }}
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.load.throughput
            value: ${{THROUGHPUT}}
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.load.connectionErrors
            value: ${{CONNECTION_ERRORS}}
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.load.requestTimeouts
            value: ${{REQUEST_TIMEOUTS}}

        - sh: pmap -x $PID | grep total | awk '{print $4}'
          then:
            - set-state: RSS
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.load.rss
            value: ${{= ${{RSS}}/1024 }}
        - script: state-array-push
          with:
            array: RUN.output.results.${{RUNTIME.name}}.load.throughputDensity
            value: ${{= ${{THROUGHPUT}}/${{RSS}}*1024 }}
        - signal: LOAD_TEST_COMPLETE
        - sh: kill -15 $PID
        - sh: sleep ${{PAUSE_TIME}}
        - script: stop-test-services
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.load.avThroughput
        array: RUN.output.results.${{RUNTIME.name}}.load.throughput
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.load.avMaxRss
        array: RUN.output.results.${{RUNTIME.name}}.load.rss
    - script: state-array-calc-max
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.load.maxThroughputDensity
        array: RUN.output.results.${{RUNTIME.name}}.load.throughputDensity
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.load.avConnectionErrors
        array: RUN.output.results.${{RUNTIME.name}}.load.connectionErrors
    - script: state-array-calc-avg
      with:
        var-name: RUN.output.results.${{RUNTIME.name}}.load.avRequestTimeouts
        array: RUN.output.results.${{RUNTIME.name}}.load.requestTimeouts

  watch-log:
    - sh: tail -f ${{log_file}}
      watch:
        - regex: "${{log_regex}}"
          then:
            - ctrlC
            - signal: LOG_REGEX_REACHED
      timer:
        1m:
          - ctrlC
          - abort: Log file ${{log_file}} didn't match regex ${{log_regex}} after 10 minutes

  monitor-processes:
    - set-signal: LOAD_TEST_COMPLETE 1
    - script:
        name: monitor-process
        async: true
      with:
        name: pidstat
        command: pidstat -u -p ${{pid}} 1
        log_file: ${{log_dir}}/pidstat-${{runtime_name}}-${{iteration}}.log
    - script:
        name: monitor-process
        async: true
      with:
        name: mpstat
        command: mpstat -P ALL 1
        log_file: ${{log_dir}}/mpstat-${{runtime_name}}-${{iteration}}.log
    - script:
        name: monitor-process
        async: true
      with:
        name: vmstat
        command: vmstat 1
        log_file: ${{log_dir}}/vmstat-${{runtime_name}}-${{iteration}}.log
    - script: monitor-postgres

  monitor-postgres:
    - sh: POSTGRES_PID=$(${{PROJ_REPO_DIR}}/scripts/infra.sh -r)
    - sh: echo $POSTGRES_PID
    - set-state: POSTGRES_PID
    - script:
        name: monitor-process
        async: true
      with:
        name: postgres-pidstat
        command: pidstat -u -p $(pgrep -d , -P ${{POSTGRES_PID}}) 1
        log_file: ${{log_dir}}/postgres-pidstat-${{runtime_name}}-${{iteration}}.log

  monitor-process:
    - queue-download: ${{log_file}}
    - sh: ${{MONITOR_CMD_PREFIX}} ${{command}} &>${{log_file}} &
    - sh: PROCESS_PID=$!
    - sh: echo $PROCESS_PID
    - set-state: PROCESS_PID
    - wait-for: ${{monitor_complete_signal:LOAD_TEST_COMPLETE}}
    - sh: kill -15 $PROCESS_PID

  download-metrics:
    - sh: mkdir -p ${{METRICS_DIR}}
    - script: sudo
      with:
        command: rm -Rf ${{METRICS_DIR}}/metrics.json
    - set-state: RUN.output.config ${{RUN.config}}
    - set-state: RUN.output.env ${{RUN.env}}
    - sh: echo '${{RUN.output}}' > ${{METRICS_DIR}}/metrics.json
      then:
      - regex: .*Permission denied
        then:
        - abort: Could not output metrics. Permission denied!
    - queue-download: ${{METRICS_DIR}}/metrics.json
#    - queue-download: ${{REPO_DIR}}/logs/*

hosts:
  target-host: ${{env.run.host.target}}

roles:
  test-runner:
    hosts:
      - target-host
    setup-scripts:
      - update-state
#      - output-vars
      - detect-os
      - capture-system-info
      - cleanup-env
      - config-env
      - ensure-requirements
      - clone-repo
      - capture-repo-info
      - stop-test-services
      - start-timestamp
    run-scripts:
      - run-tests
    cleanup-scripts:
      - stop-timestamp
      - download-metrics
      - stop-test-services
      - cleanup-env
